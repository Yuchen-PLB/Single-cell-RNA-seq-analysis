---
title: "xu16_19_29_32_vs_17_33_38"
output:
  pdf_document: default
  html_document: default
---


Start R (by typing ‘R’ at the command line) and load some R libraries as follows:

Introduction to scRNA-seq integration

Compiled: January 11, 2022
Source: vignettes/integration_introduction.Rmd

Introduction to scRNA-seq integration

The joint analysis of two or more single-cell datasets poses unique challenges. In particular, identifying cell populations that are present across multiple datasets can be problematic under standard workflows. Seurat v4 includes a set of methods to match (or ‘align’) shared cell populations across datasets. These methods first identify cross-dataset pairs of cells that are in a matched biological state (‘anchors’), can be used both to correct for technical differences between datasets (i.e. batch effect correction), and to perform comparative scRNA-seq analysis of across experimental conditions.

Below, we demonstrate methods for scRNA-seq integration as described in Stuart*, Butler* et al, 2019 to perform a comparative analysis of human immune cells (PBMC) in either a resting or interferon-stimulated state.

Integration goals
The following tutorial is designed to give you an overview of the kinds of comparative analyses on complex cell types that are possible using the Seurat integration procedure. Here, we address a few key goals:

Create an ‘integrated’ data assay for downstream analysis
Identify cell types that are present in both datasets
Obtain cell type markers that are conserved in both control and stimulated cells
Compare the datasets to find cell-type specific responses to stimulation


## https://satijalab.org/seurat/articles/integration_introduction.html


## Load all packages
```{r}

library("rlang")
library("Seurat");
library("sctransform");
library("dplyr");
library("RColorBrewer");
library("ggthemes");
library("ggplot2");
library("cowplot");
library("data.table");
library("scales")


## for slingshot 

library(tidyverse)
library(slingshot)
#library(Seurat)
library(tradeSeq)
library(S4Vectors)
library(SingleCellExperiment)


library(slingshot)
library(BUSpaRse)
library(tidyverse)
library(tidymodels)
library(Seurat)
library(scales)
library(viridis)
library(Matrix)


```


## Set up Seurat object
```{r}
## Find the origial CR path
## Find the origial CR path
# setwd path under "C:\Users\admin\Desktop\R\Single.Cell(1)\Maize.ear.tip.IP-SPM.map.to.Maizev4.TE" for loading maize matrix


#loading tip data
setwd("C:/Users/admin/Downloads/Kronos")



## Step 3: Read in the feature-barcode matrices generated by the cellranger pipeline.

memory.limit(size=50000000)

samples=c('JD1','JD2','JD3','JD5','JD6','JD7')

data.10x = list()

#data.10x[[1]] <- Read10X(data.dir = "C:\\Users\\admin\\Downloads\\Kronos\\raw.JD1.500bp3UTR");
#data.10x[[2]] <- Read10X(data.dir = "C:\\Users\\admin\\Downloads\\Kronos\\raw.JD2.500bp3UTR");
#data.10x[[3]] <- Read10X(data.dir = "C:\\Users\\admin\\Downloads\\Kronos\\raw.JD3.500bp3UTR");
data.10x[[1]] <- Read10X(data.dir = "C:\\Users\\admin\\Downloads\\Kronos\\raw.JD5");
data.10x[[2]] <- Read10X(data.dir = "C:\\Users\\admin\\Downloads\\Kronos\\raw.JD6");
data.10x[[3]] <- Read10X(data.dir = "C:\\Users\\admin\\Downloads\\Kronos\\raw.JD7");


## Convert each feature-barcode matrix to a Seurat object.

JD_5_6_7_Kronos.list = list(); # First create an empty list to hold the Seurat objects

JD_5_6_7_Kronos.list[[1]] = CreateSeuratObject(counts = data.10x[[1]], min.cells=3, min.features=200, project=samples[4]);

JD_5_6_7_Kronos.list[[1]][["DataSet"]] = samples[4];


JD_5_6_7_Kronos.list[[2]] = CreateSeuratObject(counts = data.10x[[2]], min.cells=3, min.features=200, project=samples[5]);

JD_5_6_7_Kronos.list[[2]][["DataSet"]] = samples[5];


JD_5_6_7_Kronos.list[[3]] = CreateSeuratObject(counts = data.10x[[3]], min.cells=3, min.features=200, project=samples[6]);

JD_5_6_7_Kronos.list[[3]][["DataSet"]] = samples[6];


#JD_5_6_7_Kronos.list[[4]] = CreateSeuratObject(counts = data.10x[[4]], min.cells=3, min.features=200, project=samples[4]);

#JD_5_6_7_Kronos.list[[4]][["DataSet"]] = samples[4];

#JD_5_6_7_Kronos.list[[5]] = CreateSeuratObject(counts = data.10x[[5]], min.cells=3, #min.features=200, project=samples[5]);

#JD_5_6_7_Kronos.list[[5]][["DataSet"]] = samples[5];

#JD_5_6_7_Kronos.list[[6]] = CreateSeuratObject(counts = data.10x[[6]], min.cells=3, min.features=200, project=samples[6]);

#JD_5_6_7_Kronos.list[[6]][["DataSet"]] = samples[6];
## Optional, remove the raw data to save space:

#rm(data.10x);


### Subset each library before merge or integrate


JD_5_6_7_Kronos.list[[1]] <- subset(JD_5_6_7_Kronos.list[[1]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

JD_5_6_7_Kronos.list[[2]] <- subset(JD_5_6_7_Kronos.list[[2]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

JD_5_6_7_Kronos.list[[3]] <- subset(JD_5_6_7_Kronos.list[[3]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

#JD_5_6_7_Kronos.list[[4]] <- subset(JD_5_6_7_Kronos.list[[4]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

#JD_5_6_7_Kronos.list[[5]] <- subset(JD_5_6_7_Kronos.list[[5]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

#JD_5_6_7_Kronos.list[[6]] <- subset(JD_5_6_7_Kronos.list[[6]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

##

JD_5_6_7_Kronos.list[[1]]@meta.data$source <- "W3.25"
JD_5_6_7_Kronos.list[[2]]@meta.data$source <- "W3.25"
JD_5_6_7_Kronos.list[[3]]@meta.data$source <- "W3.25"

#JD_5_6_7_Kronos.list[[4]]@meta.data$source <- "W3.0"
#JD_5_6_7_Kronos.list[[5]]@meta.data$source <- "W3.0"
#JD_5_6_7_Kronos.list[[6]]@meta.data$source <- "W3.0"



## Before seurat intergration, filter each sample separately and normalize (using same method for all samples)

## Step 8:logNormalize

JD_5_6_7_Kronos.list[[1]]<- NormalizeData(JD_5_6_7_Kronos.list[[1]], normalization.method = "LogNormalize", scale.factor = 10000)

JD_5_6_7_Kronos.list[[2]]<- NormalizeData(JD_5_6_7_Kronos.list[[2]], normalization.method = "LogNormalize", scale.factor = 10000)

JD_5_6_7_Kronos.list[[3]]<- NormalizeData(JD_5_6_7_Kronos.list[[3]], normalization.method = "LogNormalize", scale.factor = 10000)

#JD_5_6_7_Kronos.list[[4]]<- NormalizeData(JD_5_6_7_Kronos.list[[4]], normalization.method = "LogNormalize", scale.factor = 10000)


#JD_5_6_7_Kronos.list[[5]]<- NormalizeData(JD_5_6_7_Kronos.list[[4]], normalization.method = "LogNormalize", scale.factor = 10000)


#JD_5_6_7_Kronos.list[[6]]<- NormalizeData(JD_5_6_7_Kronos.list[[4]], normalization.method = "LogNormalize", scale.factor = 10000)

##Step 9:Find variables


JD_5_6_7_Kronos.list[[1]]<- FindVariableFeatures(JD_5_6_7_Kronos.list[[1]], selection.method = "vst", nfeatures = 2000)

JD_5_6_7_Kronos.list[[2]]<- FindVariableFeatures(JD_5_6_7_Kronos.list[[2]], selection.method = "vst", nfeatures = 2000)

JD_5_6_7_Kronos.list[[3]]<- FindVariableFeatures(JD_5_6_7_Kronos.list[[3]], selection.method = "vst", nfeatures = 2000)

#JD_5_6_7_Kronos.list[[4]]<- FindVariableFeatures(JD_5_6_7_Kronos.list[[4]], selection.method = "vst", nfeatures = 2000)

#JD_5_6_7_Kronos.list[[5]]<- FindVariableFeatures(JD_5_6_7_Kronos.list[[4]], selection.method = "vst", nfeatures = 2000)

#JD_5_6_7_Kronos.list[[6]]<- FindVariableFeatures(JD_5_6_7_Kronos.list[[4]], selection.method = "vst", nfeatures = 2000)


```
```{r}
# select features that are repeatedly variable across datasets for integration


features <- SelectIntegrationFeatures(object.list = JD_5_6_7_Kronos.list)

```



## Next Perform integration
## We then identify anchors using the FindIntegrationAnchors() function, which takes a list of Seurat objects as input, and use these anchors to integrate all input datasets together with IntegrateData().

```{r}

# find anchors

anchors <- FindIntegrationAnchors(object.list = JD_5_6_7_Kronos.list, anchor.features = features)


# Integrate data
# this command creates an 'integrated' data assay

JD_5_6_7_Kronos.individual.int <- IntegrateData(anchorset = anchors)

```


## Perform an integrated analysis
## Now we can run a single integrated analysis on all cells!

```{r}
# specify that we will perform downstream analysis on the corrected data note that the
# original unmodified data still resides in the 'RNA' assay

DefaultAssay(JD_5_6_7_Kronos.individual.int)<-"integrated"


# Run the standard workflow for visualization and clustering
JD_5_6_7_Kronos.individual.int <- ScaleData(JD_5_6_7_Kronos.individual.int, verbose = FALSE)
JD_5_6_7_Kronos.individual.int <- RunPCA(JD_5_6_7_Kronos.individual.int, npcs = 30, verbose = FALSE)


```



```{r}
## Optional step: Determine the ‘dimensionality’ of the dataset
## Can also use default ndims = 30. Because the results did not change dramatically. 

ElbowPlot(JD_5_6_7_Kronos.individual.int, ndims = 40)

## Elbow plot: quantitative approach
## https://hbctraining.github.io/scRNA-seq/lessons/elbow_plot_metric.html

## Based on ElbowPlot(object, ndims = 40) plot, we could roughly determine the majority of the variation by where the elbow occurs (touches the ground). While this gives us a good rough idea of the number of PCs needed to be included, a more quantitative approach may be a bit more reliable. We can calculate where the principal components start to elbow by taking the larger (should be smaller?) value of:

## 1. The point where the principal components only contribute 5% of standard deviation and the principal components cumulatively contribute 90% of the standard deviation.
## 2. The point where the percent change in variation between the consecutive PCs is less than 0.1%.

## We will start by calculating the first metric:
# Determine percent of variation associated with each PC
pct <- JD_5_6_7_Kronos.individual.int[["pca"]]@stdev / sum(JD_5_6_7_Kronos.individual.int[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1

## [1] result here (i.e. 43)

## The first metric returns PC (i.e. 43) as the PC matching these requirements. Let’s check the second metric, which identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%:

# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2

## [1] result here (i.e. 15)

## This second metric returns PC (i.e. 15). Usually, we would choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.

# Minimum of the two calculation
pcs <- min(co1, co2)

pcs


```



```{r}
JD_5_6_7_Kronos.individual.int_2 <- JD_5_6_7_Kronos.individual.int
JD_5_6_7_Kronos.individual.int <- RunUMAP(JD_5_6_7_Kronos.individual.int, reduction = "pca", dims = 1:21) ## Use default 30, or change the PC number based on above Elbow plot: quantitative approach

JD_5_6_7_Kronos.individual.int <- FindNeighbors(JD_5_6_7_Kronos.individual.int, reduction = "pca", dims = 1:21)

JD_5_6_7_Kronos.individual.int <- FindClusters(JD_5_6_7_Kronos.individual.int, resolution = 0.6)

# Visualization

DimPlot(JD_5_6_7_Kronos.individual.int, reduction = "umap", label = TRUE, pt.size = 1)
DimPlot(JD_5_6_7_Kronos.individual.int, reduction = "umap", group.by = "orig.ident")

## two plots next to each other 

p1 <- DimPlot(JD_5_6_7_Kronos.individual.int, reduction = "umap", group.by = "orig.ident")
p2 <- DimPlot(JD_5_6_7_Kronos.individual.int, reduction = "umap", label = TRUE, repel = TRUE)
p1 + p2

### split the UMAPs by samples 

DimPlot(JD_5_6_7_Kronos.individual.int, reduction = "umap", split.by = "orig.ident", pt.size = 1)

### split the UMAPs by samples 

DimPlot(JD_5_6_7_Kronos.individual.int, reduction = "umap", split.by = "source", pt.size = 1)

### group the UMAPs by samples. 

DimPlot(JD_5_6_7_Kronos.individual.int, reduction = "umap", group.by = "orig.ident", pt.size = 1)


```
```{r}
#p5 <- FeaturePlot(JD_5_6_7_Kronos.individual.int, features = c("GRMZM2G017087","GRMZM2G001289","GRMZM2G083725"), max.cutoff = 2, 
#                  cols = c("lightgrey","darkgreen"), ncol = 3)
#p6 <- FeaturePlot(JD_5_6_7_Kronos.individual.int, features = c("GRMZM2G372364","GRMZM2G165836","GRMZM2G047448"), max.cutoff = 3, ncol = 3)
#p5 / p6
```

```{r}
DefaultAssay(JD_5_6_7_Kronos.individual.int) <- "RNA"
library(readxl)
```

```{r}
Marker_Gene<-read_excel("C:/Users/admin/Desktop/100genelist.xlsx")
Gene_list <- unlist(Marker_Gene[, 5])
```

```{r}
 FeaturePlot(JD_5_6_7_Kronos.individual.int, features = Gene_list, max.cutoff = 5)
```

```{r}
unique(Marker_Gene[, 5])
```

```{r}
## plot UMIs and Genes on the UMAP

feature.pal = rev(colorRampPalette(brewer.pal(11,"Spectral"))(50))

FeaturePlot(object = JD_5_6_7_Kronos.individual.int, features = c("nCount_RNA"), cols = feature.pal, pt.size=1, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank())

FeaturePlot(object = JD_5_6_7_Kronos.individual.int, features = c("nFeature_RNA"), cols = feature.pal, pt.size=1, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank())
```


```{r}
# plot number of gene per cell on this plot. 
# https://github.com/satijalab/seurat/issues/2192
VlnPlot(JD_5_6_7_Kronos.individual.int, features = c("nFeature_RNA"), pt.size = 0.5)
```


```{r}
# plot number of transcript/UMI per cell on this plot. 
# https://github.com/satijalab/seurat/issues/2192
VlnPlot(JD_5_6_7_Kronos.individual.int, features = c("nCount_RNA"), pt.size = 0.5)
```


```{r}

VlnPlot(JD_5_6_7_Kronos.individual.int, features = c("nFeature_RNA", "nCount_RNA"), ncol=2)

```


```{r}
# Step 18: with cluster# and cell#
cell.num <- table(JD_5_6_7_Kronos.individual.int@active.ident)
ClusterLabels = paste("Cluster", names(cell.num), paste0("(n = ", cell.num, ")"))
ClusterBreaks = names(cell.num)

new.cluster.ids <- c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11","12","13","14","15",'16','17','18','19','20','21')
names(new.cluster.ids) <- levels(JD_5_6_7_Kronos.individual.int)
scrna.int<-RenameIdents(JD_5_6_7_Kronos.individual.int, new.cluster.ids)
DimPlot(JD_5_6_7_Kronos.individual.int,reduction = "umap", label = TRUE, pt.size = 1, label.size = 10) + scale_color_discrete(breaks= ClusterBreaks, labels=ClusterLabels)


```



```{r}
## Step 20:save 

saveRDS(JD_5_6_7_Kronos.individual.int, file = "JD_5_6_7_Kronos.individual.int.rds")

### in future, when open this datase

JD_5_6_7_Kronos.individual.int <- readRDS(file = "JD_5_6_7_Kronos.individual.int.rds")


```

```{r}
marker<-c(1,3,5,8,11,13,15,16,19,20,21,28,33,34,37,38,40)
selected_genes <- Gene_list[marker]
selected_genes
```

```{r}
cell_typeA_marker_gene_list <- selected_genes
object <- AddModuleScore(object = JD_5_6_7_Kronos.individual.int, features = cell_typeA_marker_gene_list, name = "cell_typeA_score")
FeaturePlot(object = object, features = "cell_typeA_score7")+
  scale_color_viridis(discrete = FALSE, option="turbo")


```
```{r}
# Loop through features from 1 to 17
for (i in 1:17) {
  feature_name <- paste0("cell_typeA_score", i)
  
  # FeaturePlot with color scale
  FeaturePlot(object = object, features = feature_name) +
    scale_color_viridis(discrete = FALSE, option = "turbo")
}

```
]
```{r}
library(viridis)

# Assuming 'object' is your Seurat object

# Features you want to plot
features <- paste0("cell_typeA_score", 1:17)

# Initialize a list to store plots
plot_list <- list()

# Loop through each feature and create FeaturePlot
for (feature in features) {
  plot <- FeaturePlot(object = object, features = feature) +
    scale_color_viridis(discrete = FALSE, option = "turbo")
  plot_list[[feature]] <- plot
}

# Save or display the plots
for (i in 1:length(features)) {
  # Save the plots
  ggsave(paste0("FeaturePlot_", features[i], ".png"), plot_list[[i]], width = 10, height = 8)
  
  # Or display the plots
  print(plot_list[[i]])
}
```
```{r}
list(Marker_Gene[marker, 5])
```
```{r}
## Remove cluster 1 with very low UMI (dead cells)

JD_5_6_7_Kronos.individual.int_remove_dead_1 <- subset(JD_5_6_7_Kronos.individual.int, idents = c('21'), invert = TRUE)

DimPlot(JD_5_6_7_Kronos.individual.int_remove_dead_1, reduction = "umap", label = TRUE, pt.size = 1)

### split the integrated object to re-normalize and process

JD_5_6_7_Kronos.rmdead.list <- SplitObject(JD_5_6_7_Kronos.individual.int_remove_dead_1, split.by = "orig.ident")

JD_5_6_7_Kronos.rmdead.list
```

```{r}
## Before seurat intergration, filter each sample separately and normalize (using same method for all samples)


## need to set RNA assay before normalization and processing 

DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[1]]) <- "RNA"
DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[2]]) <- "RNA"
DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[3]]) <- "RNA"
#DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[4]]) <- "RNA"




## Step 8:logNormalize

JD_5_6_7_Kronos.rmdead.list[[1]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[1]], normalization.method = "LogNormalize", scale.factor = 10000)

JD_5_6_7_Kronos.rmdead.list[[2]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[2]], normalization.method = "LogNormalize", scale.factor = 10000)

JD_5_6_7_Kronos.rmdead.list[[3]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[3]], normalization.method = "LogNormalize", scale.factor = 10000)

#JD_5_6_7_Kronos.rmdead.list[[4]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[4]], normalization.method = "LogNormalize", scale.factor = 10000)

```

```{r}
##Step 9:Find variables

JD_5_6_7_Kronos.rmdead.list[[1]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[1]], selection.method = "vst", nfeatures = 2000)

JD_5_6_7_Kronos.rmdead.list[[2]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[2]], selection.method = "vst", nfeatures = 2000)

JD_5_6_7_Kronos.rmdead.list[[3]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[3]], selection.method = "vst", nfeatures = 2000)

#JD_5_6_7_Kronos.rmdead.list[[4]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[4]], selection.method = "vst", nfeatures = 2000)


# select features that are repeatedly variable across datasets for integration


features <- SelectIntegrationFeatures(object.list = JD_5_6_7_Kronos.rmdead.list)

```




## Next Perform integration
## We then identify anchors using the FindIntegrationAnchors() function, which takes a list of Seurat objects as input, and use these anchors to integrate all input datasets together with IntegrateData().

```{r}

# find anchors

anchors <- FindIntegrationAnchors(object.list = JD_5_6_7_Kronos.rmdead.list, anchor.features = features)


# Integrate data
# this command creates an 'integrated' data assay

JD_5_6_7_Kronos.individual.rmdead.int <- IntegrateData(anchorset = anchors)

```


## Perform an integrated analysis
## Now we can run a single integrated analysis on all cells!

```{r}
# specify that we will perform downstream analysis on the corrected data note that the
# original unmodified data still resides in the 'RNA' assay

DefaultAssay(JD_5_6_7_Kronos.individual.rmdead.int)<-"integrated"


# Run the standard workflow for visualization and clustering
JD_5_6_7_Kronos.individual.rmdead.int <- ScaleData(JD_5_6_7_Kronos.individual.rmdead.int, verbose = FALSE)
JD_5_6_7_Kronos.individual.rmdead.int <- RunPCA(JD_5_6_7_Kronos.individual.rmdead.int, npcs = 30, verbose = FALSE)


```



```{r}
## Optional step: Determine the ‘dimensionality’ of the dataset
## Can also use default ndims = 30. Because the results did not change dramatically
ElbowPlot(JD_5_6_7_Kronos.individual.rmdead.int, ndims = 40)

## Elbow plot: quantitative approach
## https://hbctraining.github.io/scRNA-seq/lessons/elbow_plot_metric.html

## Based on ElbowPlot(object, ndims = 40) plot, we could roughly determine the majority of the variation by where the elbow occurs (touches the ground). While this gives us a good rough idea of the number of PCs needed to be included, a more quantitative approach may be a bit more reliable. We can calculate where the principal components start to elbow by taking the larger (should be smaller?) value of:

## 1. The point where the principal components only contribute 5% of standard deviation and the principal components cumulatively contribute 90% of the standard deviation.
## 2. The point where the percent change in variation between the consecutive PCs is less than 0.1%.

## We will start by calculating the first metric:
# Determine percent of variation associated with each PC
pct <- JD_5_6_7_Kronos.individual.rmdead.int[["pca"]]@stdev / sum(JD_5_6_7_Kronos.individual.rmdead.int[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1

## [1] result here (i.e. 43)

## The first metric returns PC (i.e. 43) as the PC matching these requirements. Let’s check the second metric, which identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%:

# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2

## [1] result here (i.e. 15)

## This second metric returns PC (i.e. 15). Usually, we would choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.

# Minimum of the two calculation
pcs <- min(co1, co2)

pcs



```



```{r}
JD_5_6_7_Kronos.individual.rmdead.int <- RunUMAP(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "pca", dims = 1:21) ## Use default 30, or change the PC number based on above Elbow plot: quantitative approach

JD_5_6_7_Kronos.individual.rmdead.int <- FindNeighbors(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "pca", dims = 1:21)

JD_5_6_7_Kronos.individual.rmdead.int <- FindClusters(JD_5_6_7_Kronos.individual.rmdead.int, resolution = 0.65)

# Visualization

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", label = TRUE, pt.size = 1)

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", group.by = "orig.ident")

## two plots next to each other 

p1 <- DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", group.by = "orig.ident")
p2 <- DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", label = TRUE, repel = TRUE)
p1 + p2

### split the UMAPs by samples 

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", split.by = "orig.ident", pt.size = 1)


### group the UMAPs by samples. 

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", group.by = "orig.ident", pt.size = 1)

```


```{r}
## plot UMIs and Genes on the UMAP

feature.pal = rev(colorRampPalette(brewer.pal(11,"Spectral"))(50))

FeaturePlot(object = JD_5_6_7_Kronos.individual.rmdead.int, features = c("nCount_RNA"), cols = feature.pal, pt.size=1, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank())

FeaturePlot(object = JD_5_6_7_Kronos.individual.rmdead.int, features = c("nFeature_RNA"), cols = feature.pal, pt.size=1, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank())
```


```{r}
# plot number of gene per cell on this plot. 
# https://github.com/satijalab/seurat/issues/2192
VlnPlot(JD_5_6_7_Kronos.individual.rmdead.int, features = c("nFeature_RNA"), pt.size = 0.5)
```


```{r}
# plot number of transcript/UMI per cell on this plot. 
# https://github.com/satijalab/seurat/issues/2192
VlnPlot(JD_5_6_7_Kronos.individual.rmdead.int, features = c("nCount_RNA"), pt.size = 0.5)
```


```{r}

VlnPlot(JD_5_6_7_Kronos.individual.rmdead.int, features = c("nFeature_RNA", "nCount_RNA"), ncol=2)

```


```{r}
# UMAP cluster# and cell#
cell.num <- table(JD_5_6_7_Kronos.individual.rmdead.int@active.ident)
ClusterLabels = paste("Cluster", names(cell.num), paste0("(n = ", cell.num, ")"))
ClusterBreaks = names(cell.num)

new.cluster.ids <- c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11","12","13","14",'15','16','17','18','19')
names(new.cluster.ids) <- levels(JD_5_6_7_Kronos.individual.rmdead.int)
scrna.int<-RenameIdents(JD_5_6_7_Kronos.individual.rmdead.int, new.cluster.ids)
DimPlot(JD_5_6_7_Kronos.individual.rmdead.int,reduction = "umap", label = TRUE, pt.size = 1, label.size = 10) + scale_color_discrete(breaks= ClusterBreaks, labels=ClusterLabels)


```



```{r}
## Step 20:save 

saveRDS(JD_5_6_7_Kronos.individual.rmdead.int, file = "JD_5_6_7_Kronos.individual.int.rmDead.recluster.rds")

### in future, when open this datase

JD_5_6_7_Kronos.individual.rmdead.int <- readRDS(file = "JD_5_6_7_Kronos.individual.int.rmDead.recluster.rds")


```

```{r}
## Remove cluster 1 with very low UMI (dead cells)

JD_5_6_7_Kronos.individual.int_remove_dead_1 <- subset(JD_5_6_7_Kronos.individual.rmdead.int, idents = c('19'), invert = TRUE)

DimPlot(JD_5_6_7_Kronos.individual.int_remove_dead_1, reduction = "umap", label = TRUE, pt.size = 1)

### split the integrated object to re-normalize and process

JD_5_6_7_Kronos.rmdead.list <- SplitObject(JD_5_6_7_Kronos.individual.int_remove_dead_1, split.by = "orig.ident")

JD_5_6_7_Kronos.rmdead.list
```

```{r}
## Before seurat intergration, filter each sample separately and normalize (using same method for all samples)


## need to set RNA assay before normalization and processing 

DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[1]]) <- "RNA"
DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[2]]) <- "RNA"
DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[3]]) <- "RNA"
#DefaultAssay(JD_5_6_7_Kronos.rmdead.list[[4]]) <- "RNA"




## Step 8:logNormalize

JD_5_6_7_Kronos.rmdead.list[[1]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[1]], normalization.method = "LogNormalize", scale.factor = 10000)

JD_5_6_7_Kronos.rmdead.list[[2]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[2]], normalization.method = "LogNormalize", scale.factor = 10000)

JD_5_6_7_Kronos.rmdead.list[[3]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[3]], normalization.method = "LogNormalize", scale.factor = 10000)

#JD_5_6_7_Kronos.rmdead.list[[4]]<- NormalizeData(JD_5_6_7_Kronos.rmdead.list[[4]], normalization.method = "LogNormalize", scale.factor = 10000)

```

```{r}
##Step 9:Find variables

JD_5_6_7_Kronos.rmdead.list[[1]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[1]], selection.method = "vst", nfeatures = 2000)

JD_5_6_7_Kronos.rmdead.list[[2]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[2]], selection.method = "vst", nfeatures = 2000)

JD_5_6_7_Kronos.rmdead.list[[3]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[3]], selection.method = "vst", nfeatures = 2000)

#JD_5_6_7_Kronos.rmdead.list[[4]]<- FindVariableFeatures(JD_5_6_7_Kronos.rmdead.list[[4]], selection.method = "vst", nfeatures = 2000)


# select features that are repeatedly variable across datasets for integration


features <- SelectIntegrationFeatures(object.list = JD_5_6_7_Kronos.rmdead.list)

```




## Next Perform integration
## We then identify anchors using the FindIntegrationAnchors() function, which takes a list of Seurat objects as input, and use these anchors to integrate all input datasets together with IntegrateData().

```{r}

# find anchors

anchors <- FindIntegrationAnchors(object.list = JD_5_6_7_Kronos.rmdead.list, anchor.features = features)


# Integrate data
# this command creates an 'integrated' data assay

JD_5_6_7_Kronos.individual.rmdead.int <- IntegrateData(anchorset = anchors)

```


## Perform an integrated analysis
## Now we can run a single integrated analysis on all cells!

```{r}
# specify that we will perform downstream analysis on the corrected data note that the
# original unmodified data still resides in the 'RNA' assay

DefaultAssay(JD_5_6_7_Kronos.individual.rmdead.int)<-"integrated"


# Run the standard workflow for visualization and clustering
JD_5_6_7_Kronos.individual.rmdead.int <- ScaleData(JD_5_6_7_Kronos.individual.rmdead.int, verbose = FALSE)
JD_5_6_7_Kronos.individual.rmdead.int <- RunPCA(JD_5_6_7_Kronos.individual.rmdead.int, npcs = 30, verbose = FALSE)


```



```{r}
## Optional step: Determine the ‘dimensionality’ of the dataset
## Can also use default ndims = 30. Because the results did not change dramatically
ElbowPlot(JD_5_6_7_Kronos.individual.rmdead.int, ndims = 40)

## Elbow plot: quantitative approach
## https://hbctraining.github.io/scRNA-seq/lessons/elbow_plot_metric.html

## Based on ElbowPlot(object, ndims = 40) plot, we could roughly determine the majority of the variation by where the elbow occurs (touches the ground). While this gives us a good rough idea of the number of PCs needed to be included, a more quantitative approach may be a bit more reliable. We can calculate where the principal components start to elbow by taking the larger (should be smaller?) value of:

## 1. The point where the principal components only contribute 5% of standard deviation and the principal components cumulatively contribute 90% of the standard deviation.
## 2. The point where the percent change in variation between the consecutive PCs is less than 0.1%.

## We will start by calculating the first metric:
# Determine percent of variation associated with each PC
pct <- JD_5_6_7_Kronos.individual.rmdead.int[["pca"]]@stdev / sum(JD_5_6_7_Kronos.individual.rmdead.int[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1

## [1] result here (i.e. 43)

## The first metric returns PC (i.e. 43) as the PC matching these requirements. Let’s check the second metric, which identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%:

# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2

## [1] result here (i.e. 15)

## This second metric returns PC (i.e. 15). Usually, we would choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.

# Minimum of the two calculation
pcs <- min(co1, co2)

pcs



```



```{r}
JD_5_6_7_Kronos.individual.rmdead.int <- RunUMAP(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "pca", dims = 1:21) ## Use default 30, or change the PC number based on above Elbow plot: quantitative approach

JD_5_6_7_Kronos.individual.rmdead.int <- FindNeighbors(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "pca", dims = 1:21)

JD_5_6_7_Kronos.individual.rmdead.int <- FindClusters(JD_5_6_7_Kronos.individual.rmdead.int, resolution = 0.65)

# Visualization

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", label = TRUE, pt.size = 1)

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", group.by = "orig.ident")

## two plots next to each other 

p1 <- DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", group.by = "orig.ident")
p2 <- DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", label = TRUE, repel = TRUE)
p1 + p2

### split the UMAPs by samples 

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", split.by = "orig.ident", pt.size = 1)


### group the UMAPs by samples. 

DimPlot(JD_5_6_7_Kronos.individual.rmdead.int, reduction = "umap", group.by = "orig.ident", pt.size = 1)

```


```{r}
## plot UMIs and Genes on the UMAP

feature.pal = rev(colorRampPalette(brewer.pal(11,"Spectral"))(50))

FeaturePlot(object = JD_5_6_7_Kronos.individual.rmdead.int, features = c("nCount_RNA"), cols = feature.pal, pt.size=1, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank())

FeaturePlot(object = JD_5_6_7_Kronos.individual.rmdead.int, features = c("nFeature_RNA"), cols = feature.pal, pt.size=1, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank())
```


```{r}
# plot number of gene per cell on this plot. 
# https://github.com/satijalab/seurat/issues/2192
VlnPlot(JD_5_6_7_Kronos.individual.rmdead.int, features = c("nFeature_RNA"), pt.size = 0.5)
```


```{r}
# plot number of transcript/UMI per cell on this plot. 
# https://github.com/satijalab/seurat/issues/2192
VlnPlot(JD_5_6_7_Kronos.individual.rmdead.int, features = c("nCount_RNA"), pt.size = 0.5)
```


```{r}

VlnPlot(JD_5_6_7_Kronos.individual.rmdead.int, features = c("nFeature_RNA", "nCount_RNA"), ncol=2)

```


```{r}
# UMAP cluster# and cell#
cell.num <- table(JD_5_6_7_Kronos.individual.rmdead.int@active.ident)
ClusterLabels = paste("Cluster", names(cell.num), paste0("(n = ", cell.num, ")"))
ClusterBreaks = names(cell.num)

new.cluster.ids <- c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11","12","13","14",'15','16','17','18','19')
names(new.cluster.ids) <- levels(JD_5_6_7_Kronos.individual.rmdead.int)
scrna.int<-RenameIdents(JD_5_6_7_Kronos.individual.rmdead.int, new.cluster.ids)
DimPlot(JD_5_6_7_Kronos.individual.rmdead.int,reduction = "umap", label = TRUE, pt.size = 1, label.size = 10) + scale_color_discrete(breaks= ClusterBreaks, labels=ClusterLabels)


```



```{r}
## Step 20:save 

saveRDS(JD_5_6_7_Kronos.individual.rmdead.int, file = "JD_5_6_7_Kronos.individual.int.rmDead.recluster.rds")

### in future, when open this datase

JD_5_6_7_Kronos.individual.rmdead.int <- readRDS(file = "JD_5_6_7_Kronos.individual.int.rmDead.recluster.rds")


```
```{r}
getwd()
```

